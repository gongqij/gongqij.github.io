<!doctype html><html lang=en>
<head>
<title>
go之同步原语
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="同步原语与锁 Mutex 数据结构 type Mutex struct { state int32 //表示当前互斥锁的状态 	sema uint32 //用于控制锁状态的信号量 } 互斥锁的状态 互斥锁的状态比较复杂，如下图所示，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放：
图 6-6 互斥锁的状态
在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：
 mutexLocked — 表示互斥锁的锁定状态； mutexWoken — 表示从正常模式被从唤醒； mutexStarving — 当前的互斥锁进入饥饿状态；  互斥锁的正常模式和饥饿模式 sync.Mutex 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么，它们有什么样的关系。
在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』。
图 6-7 互斥锁的正常模式与饥饿模式
饥饿模式是在 Go 语言 1.9 版本引入的优化1，引入的目的是保证互斥锁的公平性（Fairness）。
在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=/posts/go%E4%B9%8B%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/>
<link rel=stylesheet href=/assets/style.css>
<link rel=stylesheet href=/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/favicon.png>
<link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="go之同步原语">
<meta name=twitter:description content="同步原语与锁 Mutex 数据结构 type Mutex struct { state int32 //表示当前互斥锁的状态 	sema uint32 //用于控制锁状态的信号量 } 互斥锁的状态 互斥锁的状态比较复杂，如下图所示，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放：
图 6-6 互斥锁的状态
在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：
 mutexLocked — 表示互斥锁的锁定状态； mutexWoken — 表示从正常模式被从唤醒； mutexStarving — 当前的互斥锁进入饥饿状态；  互斥锁的正常模式和饥饿模式 sync.Mutex 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么，它们有什么样的关系。
在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』。
图 6-7 互斥锁的正常模式与饥饿模式
饥饿模式是在 Go 语言 1.9 版本引入的优化1，引入的目的是保证互斥锁的公平性（Fairness）。
在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。">
<meta property="og:title" content="go之同步原语">
<meta property="og:description" content="同步原语与锁 Mutex 数据结构 type Mutex struct { state int32 //表示当前互斥锁的状态 	sema uint32 //用于控制锁状态的信号量 } 互斥锁的状态 互斥锁的状态比较复杂，如下图所示，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放：
图 6-6 互斥锁的状态
在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：
 mutexLocked — 表示互斥锁的锁定状态； mutexWoken — 表示从正常模式被从唤醒； mutexStarving — 当前的互斥锁进入饥饿状态；  互斥锁的正常模式和饥饿模式 sync.Mutex 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么，它们有什么样的关系。
在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』。
图 6-7 互斥锁的正常模式与饥饿模式
饥饿模式是在 Go 语言 1.9 版本引入的优化1，引入的目的是保证互斥锁的公平性（Fairness）。
在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。">
<meta property="og:type" content="article">
<meta property="og:url" content="/posts/go%E4%B9%8B%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-29T11:14:03+08:00">
<meta property="article:modified_time" content="2021-11-29T11:14:03+08:00"><meta property="og:site_name" content="K:)eep">
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__text>K:)eep</span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=https://github.com/gongqij>Github</a></li>
<li><a href=/>Home</a></li>
<li><a href=/posts/readlist>ReadList</a></li>
<li><a href=/posts/wechat>WeChat</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=https://github.com/gongqij>Github</a></li>
<li><a href=/>Home</a></li>
<li><a href=/posts/readlist>ReadList</a></li>
<li><a href=/posts/wechat>WeChat</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 6a6 6 0 016 6c0 2.22-1.21 4.16-3 5.2V19a1 1 0 01-1 1H10A1 1 0 019 19V17.2C7.21 16.16 6 14.22 6 12a6 6 0 016-6m2 15v1a1 1 0 01-1 1H11a1 1 0 01-1-1V21h4m6-10h3v2H20V11M1 11H4v2H1V11M13 1V4H11V1h2M4.92 3.5 7.05 5.64 5.63 7.05 3.5 4.93 4.92 3.5M16.95 5.63 19.07 3.5 20.5 4.93 18.37 7.05 16.95 5.63z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=post>
<h1 class=post-title style=text-align:center>go之同步原语</h1>
<div class=post-meta style=text-align:center;color:#999>
<span class=post-date>
2021-11-29
</span>
<span class=post-read-time>· 6 min read</span>
</div>
<div class=post-content>
<h1 id=同步原语与锁>同步原语与锁</h1>
<h2 id=mutex><a href=#mutex class=h-anchor>#</a>Mutex</h2>
<h3 id=数据结构><a href=#数据结构 class=h-anchor>#</a>数据结构</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mutex</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>state</span> <span style=color:#66d9ef>int32</span>  <span style=color:#75715e>//表示当前互斥锁的状态
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sema</span>  <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>//用于控制锁状态的信号量
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=互斥锁的状态><a href=#互斥锁的状态 class=h-anchor>#</a>互斥锁的状态</h3>
<p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放：</p>
<p><img src=https://img.draveness.me/2020-01-23-15797104328010-golang-mutex-state.png alt=golang-mutex-state></p>
<p><strong>图 6-6 互斥锁的状态</strong></p>
<p>在默认情况下，互斥锁的所有状态位都是 <code>0</code>，<code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
</ul>
<h3 id=互斥锁的正常模式和饥饿模式><a href=#互斥锁的正常模式和饥饿模式 class=h-anchor>#</a>互斥锁的正常模式和饥饿模式</h3>
<p><a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28><code>sync.Mutex</code></a> 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么，它们有什么样的关系。</p>
<p>在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』。</p>
<p><img src=https://img.draveness.me/2020-01-23-15797104328020-golang-mutex-mode.png alt=golang-mutex-mode></p>
<p><strong>图 6-7 互斥锁的正常模式与饥饿模式</strong></p>
<p>饥饿模式是在 Go 语言 <a href=https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be>1.9</a> 版本引入的优化<a href=https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#fn:1>1</a>，引入的目的是保证互斥锁的公平性（Fairness）。</p>
<p>在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。</p>
<p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p>
<h3 id=cas><a href=#cas class=h-anchor>#</a>CAS</h3>
<h4 id=什么是cas><a href=#什么是cas class=h-anchor>#</a>什么是CAS？</h4>
<p><code>CAS</code>即<code>Compare And Swap</code>的缩写，翻译成中文就是<strong>比较并交换</strong>，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是<strong>原子性</strong>的操作(读和写两者同时具有原子性)，其实现方式是通过借助<code>C/C++</code>调用CPU指令完成的，所以效率很高。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span>)
<span style=color:#75715e>//更新m.state字段之前先比较m.state和old是否相等，如果相等，new写入m.state,函数返回true；如果不相等，返回函数false。
</span><span style=color:#75715e>//CAS机制中的这些步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题
</span></code></pre></div><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p>
<ol>
<li>乐观锁 <strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li>
<li>悲观锁 <strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久。</li>
</ol>
<h4 id=cas的缺点><a href=#cas的缺点 class=h-anchor>#</a>CAS的缺点</h4>
<ol>
<li>
<p>ABA问题</p>
<p>在多线程场景下<code>CAS</code>会出现<code>ABA</code>问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这三个线程如下</p>
<ol>
<li>线程1，期望值为A，欲更新的值为B</li>
<li>线程2，期望值为A，欲更新的值为B</li>
</ol>
<p>线程<code>1</code>抢先获得CPU时间片，而线程<code>2</code>因为其他原因阻塞了，线程<code>1</code>取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候<strong>出现了线程<code>3</code>，期望值为B，欲更新的值为A</strong>，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程<code>2</code>从阻塞中恢复，并且获得了CPU时间片，这时候线程<code>2</code>取值与期望的值A比较，发现相等则将值更新为B，虽然线程<code>2</code>也完成了操作，但是线程<code>2</code>并不知道值已经经过了<code>A->B->A</code>的变化过程。</p>
<p><strong><code>ABA</code>问题带来的危害</strong>：
小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50
线程1（提款机）：获取当前值100，期望更新为50，
线程2（提款机）：获取当前值100，期望更新为50，
线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50
线程3（默认）：获取当前值50，期望更新为100，
这时候线程3成功执行，余额变为100，
线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！
此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。</p>
<p><strong>解决方法</strong>： 在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A->B->A</code>就变成了<code>1A->2B->3A</code>。</p>
</li>
<li>
<p>可能会消耗较高的CPU
看起来CAS比锁的效率高，<strong>从阻塞机制变成了非阻塞机制</strong>，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在<strong>竞争</strong>，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p>
<p>如果<code>CAS</code>操作失败，就需要循环进行<code>CAS</code>操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。</p>
<blockquote>
<p>这种循环也称为自旋</p>
</blockquote>
<p><strong>解决方法</strong>： 限制自旋次数，防止进入死循环。</p>
</li>
<li>
<p>只能保证一个共享变量的原子操作</p>
<p><code>CAS</code>的原子操作只能针对一个共享变量。</p>
<p><strong>解决方法</strong>： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p>
</li>
</ol>
<h4 id=cas的优点><a href=#cas的优点 class=h-anchor>#</a>CAS的优点</h4>
<p>可以保证变量操作的原子性；
并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；
在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</p>
<h3 id=自旋><a href=#自旋 class=h-anchor>#</a>自旋</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_doSpin</span>() {
	<span style=color:#a6e22e>procyield</span>(<span style=color:#a6e22e>active_spin_cnt</span>)
}

<span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>procyield</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>cycles</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>
<span style=color:#a6e22e>again</span>:
	<span style=color:#a6e22e>PAUSE</span>
	<span style=color:#a6e22e>SUBL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>AX</span>
	<span style=color:#a6e22e>JNZ</span>	<span style=color:#a6e22e>again</span>
	<span style=color:#a6e22e>RET</span>
</code></pre></div><p><strong>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序</strong>.</p>
<h4 id=goroutine-进入自旋的条件><a href=#goroutine-进入自旋的条件 class=h-anchor>#</a>Goroutine 进入自旋的条件</h4>
<ol>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li><code>sync.runtime_canSpin</code>需要返回true：
<ol>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ol>
</li>
</ol>
<h4 id=为什么自旋时使用pause指令><a href=#为什么自旋时使用pause指令 class=h-anchor>#</a>为什么自旋时使用PAUSE指令？</h4>
<p>当spinlock执行lock()获得锁失败后会进行busy loop，不断检测锁状态，尝试获得锁。这么做有一个缺陷：频繁的检测会让流水线上充满了读操作。另外一个线程往流水线上丢入一个锁变量写操作的时候，必须对流水线进行重排，因为CPU必须保证所有读操作读到正确的值。流水线重排十分耗时，影响lock()的性能。</p>
<p>为了解决这个问题，intel发明了pause指令。这个指令的本质功能：让加锁失败时cpu睡眠30个（about）clock，从而使得读操作的频率低很多。流水线重排的代价也会小很多。</p>
<p>Pause指令解释（from intel）：</p>
<p>Description</p>
<p>Improves the performance of spin-wait loops. When executing a “spin-wait loop,” a Pentium 4 or Intel Xeon processor suffers a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.</p>
<p>提升spin-wait-loop的性能，当执行spin-wait循环的时候，笨死和小强处理器会因为在退出循环的时候检测到memory order violation而导致严重的性能损失，pause指令就相当于提示处理器哥目前处于spin-wait中。在绝大多数情况下，处理器根据这个提示来避免violation，藉此大幅提高性能，由于这个原因，我们建议在spin-wait中加上一个pause指令。</p>
<p>名词解释(以下为本人猜想)：memory order violation，直译为-内存访问顺序冲突，当处理器在(out of order)乱序执行的流水线上去内存load某个内存地址的值(此处是lock)的时候，发现这个值正在被store，而且store本身就在load之前，对于处理器来说，这就是一个hazard，流水流不起来。</p>
<p>在本文中，具体是指当一个获得锁的工作线程W从临界区退出，在调用unlock释放锁的时候，有若干个等待线程S都在自旋检测锁是否可用，此时W线程会产生一个store指令，若干个S线程会产生很多load指令，在store之后的load指令要等待store在流水线上执行完毕才能执行，由于处理器是乱序执行，在没有store指令之前，处理器对多个没有依赖的load是可以随机乱序执行的，当有了store指令之后，需要reorder重新排序执行，此时会严重影响处理器性能，按照intel的说法，会带来25倍的性能损失。Pause指令的作用就是减少并行load的数量，从而减少reorder时所耗时间。</p>
<h3 id=加锁和解锁><a href=#加锁和解锁 class=h-anchor>#</a>加锁和解锁</h3>
<h4 id=加锁><a href=#加锁 class=h-anchor>#</a>加锁</h4>
<p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，就会直接通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 并且在普通模式下工作，就会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 <a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72><code>sync.runtime_SemacquireMutex</code></a> 函数将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒当前 Goroutine；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，当前 Goroutine 会将互斥锁切换回正常模式；</li>
</ul>
<h4 id=解锁><a href=#解锁 class=h-anchor>#</a>解锁</h4>
<ul>
<li>当互斥锁已经被解锁时，那么调用 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，会直接将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，就会直接返回；在其他情况下会通过 <a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li>
</ul>
<h2 id=rwmutex><a href=#rwmutex class=h-anchor>#</a>RWMutex</h2>
<h3 id=数据结构-1><a href=#数据结构-1 class=h-anchor>#</a>数据结构</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RWMutex</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>w</span>           <span style=color:#a6e22e>Mutex</span>
	<span style=color:#a6e22e>writerSem</span>   <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>readerSem</span>   <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>readerCount</span> <span style=color:#66d9ef>int32</span>
	<span style=color:#a6e22e>readerWait</span>  <span style=color:#66d9ef>int32</span>
}
<span style=color:#75715e>//w — 复用互斥锁提供的能力；
</span><span style=color:#75715e>//writerSem 和 readerSem — 分别用于写等待读和读等待写：
</span><span style=color:#75715e>//readerCount 存储了当前正在执行的读操作的数量；
</span><span style=color:#75715e>//readerWait 表示当写操作被阻塞时等待的读操作个数；
</span></code></pre></div><h3 id=写锁><a href=#写锁 class=h-anchor>#</a>写锁</h3>
<h3 id=读锁><a href=#读锁 class=h-anchor>#</a>读锁</h3>
<p>读锁的加锁方法 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L43-L56><code>sync.RWMutex.RLock</code></a> 很简单，该方法会通过 <a href=https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93><code>atomic.AddInt32</code></a> 将 <code>readerCount</code> 加一：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RWMutex</span>) <span style=color:#a6e22e>RLock</span>() {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>rw</span>.<span style=color:#a6e22e>readerCount</span>, <span style=color:#ae81ff>1</span>) &lt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>runtime_SemacquireMutex</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>rw</span>.<span style=color:#a6e22e>readerSem</span>, <span style=color:#66d9ef>false</span>, <span style=color:#ae81ff>0</span>)
	}
}
</code></pre></div><ol>
<li>如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72><code>sync.runtime_SemacquireMutex</code></a> 陷入休眠等待锁的释放；</li>
<li>如果该方法的结果为非负数 — 没有 Goroutine 获得写锁，当前方法就会成功返回；</li>
</ol>
<p>当 Goroutine 想要释放读锁时，会调用如下所示的 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75><code>sync.RWMutex.RUnlock</code></a> 方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RWMutex</span>) <span style=color:#a6e22e>RUnlock</span>() {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>rw</span>.<span style=color:#a6e22e>readerCount</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>); <span style=color:#a6e22e>r</span> &lt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>rw</span>.<span style=color:#a6e22e>rUnlockSlow</span>(<span style=color:#a6e22e>r</span>)
	}
}
</code></pre></div><p>该方法会先减少正在读资源的 <code>readerCount</code> 整数，根据 <a href=https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93><code>atomic.AddInt32</code></a> 的返回值不同会分别进行处理：</p>
<ul>
<li>如果返回值大于等于零 — 读锁直接解锁成功；</li>
<li>如果返回值小于零 — 有一个正在执行的写操作，在这时会调用<a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87><code>sync.RWMutex.rUnlockSlow</code></a> 方法；</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RWMutex</span>) <span style=color:#a6e22e>rUnlockSlow</span>(<span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int32</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>rwmutexMaxReaders</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;sync: RUnlock of unlocked RWMutex&#34;</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>rw</span>.<span style=color:#a6e22e>readerWait</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>runtime_Semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>rw</span>.<span style=color:#a6e22e>writerSem</span>, <span style=color:#66d9ef>false</span>, <span style=color:#ae81ff>1</span>)
	}
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87><code>sync.RWMutex.rUnlockSlow</code></a> 会减少获取锁的写操作等待的读操作数 <code>readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量 <code>writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</p>
<p>读写互斥锁 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34><code>sync.RWMutex</code></a> 虽然提供的功能非常复杂，不过因为它建立在 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28><code>sync.Mutex</code></a> 上，所以整体的实现上会简单很多。我们总结一下读锁和写锁的关系：</p>
<ul>
<li>调用<code>sync.RWMutex.Lock</code>尝试获取写锁时；
<ul>
<li>每次 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75><code>sync.RWMutex.RUnlock</code></a> 都会将 <code>readerCount</code> 其减一，当它归零时该 Goroutine 就会获得写锁；</li>
<li>将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li>
</ul>
</li>
<li>调用 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140><code>sync.RWMutex.Unlock</code></a> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>
</ul>
<p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p>
<h2 id=waitgroup><a href=#waitgroup class=h-anchor>#</a>WaitGroup</h2>
<p><a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>requests</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>{<span style=color:#f92672>...</span>}
<span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(len(<span style=color:#a6e22e>requests</span>))

<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>request</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>requests</span> {
    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
        <span style=color:#75715e>// res, err := service.call(r)
</span><span style=color:#75715e></span>    }(<span style=color:#a6e22e>request</span>)
}
<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</code></pre></div><p>我们可以通过 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29><code>sync.WaitGroup</code></a> 将原本顺序执行的代码在多个 Goroutine 中并发执行，加快程序处理的速度。</p>
<p><img src=https://img.draveness.me/2020-01-23-15797104328028-golang-syncgroup.png alt=golang-syncgroup></p>
<p><strong>图 6-8 WaitGroup 等待多个 Goroutine</strong></p>
<h3 id=数据结构-2><a href=#数据结构-2 class=h-anchor>#</a>数据结构</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WaitGroup</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>noCopy</span> <span style=color:#a6e22e>noCopy</span>
	<span style=color:#a6e22e>state1</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>uint32</span>
}
</code></pre></div><h3 id=小结><a href=#小结 class=h-anchor>#</a>小结</h3>
<ul>
<li><a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29><code>sync.WaitGroup</code></a> 必须在 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li>
<li><a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100><code>sync.WaitGroup.Done</code></a> 只是对 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；</li>
<li>可以同时有多个 Goroutine 等待当前 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li>
</ul>
<h2 id=once><a href=#once class=h-anchor>#</a>Once</h2>
<p>Go 语言标准库中 <a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。在运行如下所示的代码时，我们会看到如下所示的运行结果：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>o</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Once</span>{}
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#66d9ef>func</span>() {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;only once&#34;</span>)
        })
    }
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>only</span> <span style=color:#a6e22e>once</span>
</code></pre></div><h3 id=结构体><a href=#结构体 class=h-anchor>#</a>结构体</h3>
<p>每一个 <a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20><code>sync.Once</code></a> 结构体中都只包含一个用于标识代码块是否执行过的 <code>done</code> 以及一个互斥锁 <a href=https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28><code>sync.Mutex</code></a>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Once</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>done</span> <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>m</span>    <span style=color:#a6e22e>Mutex</span>
}
</code></pre></div><h3 id=接口><a href=#接口 class=h-anchor>#</a>接口</h3>
<p><a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59><code>sync.Once.Do</code></a> 是 <a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20><code>sync.Once</code></a> 结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：</p>
<ul>
<li>如果传入的函数已经执行过，就会直接返回；</li>
<li>如果传入的函数没有执行过，就会调用 <a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L61-L68><code>sync.Once.doSlow</code></a> 执行传入的函数：</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Once</span>) <span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>()) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUint32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>done</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>doSlow</span>(<span style=color:#a6e22e>f</span>)
	}
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Once</span>) <span style=color:#a6e22e>doSlow</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>()) {
	<span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>done</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>StoreUint32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>done</span>, <span style=color:#ae81ff>1</span>)
		<span style=color:#a6e22e>f</span>()
	}
}
</code></pre></div><ol>
<li>为当前 Goroutine 获取互斥锁；</li>
<li>执行传入的无入参函数；</li>
<li>运行延迟函数调用，将成员变量 <code>done</code> 更新成 1；</li>
</ol>
<p><a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20><code>sync.Once</code></a> 就会通过成员变量 <code>done</code> 确保函数不会执行第二次。</p>
<h3 id=小结-1><a href=#小结-1 class=h-anchor>#</a>小结</h3>
<p>作为用于保证函数执行次数的 <a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a href=https://github.com/golang/go/tree/master/src/sync/atomic><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p>
<ul>
<li><a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li>
<li>两次调用 <a href=https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59><code>sync.Once.Do</code></a> 方法传入不同的函数也只会执行第一次调用的函数；</li>
</ul>
<h2 id=cond><a href=#cond class=h-anchor>#</a>Cond</h2>
<p>Go 语言标准库中的 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29><code>sync.Cond</code></a> 一个条件变量，它可以让一系列的 Goroutine 都在满足特定条件时被唤醒。每一个 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁，我们可以通过下面的例子了解它的使用方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>status</span> <span style=color:#66d9ef>int64</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>NewCond</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>{})
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>listen</span>(<span style=color:#a6e22e>c</span>)
	}
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>broadcast</span>(<span style=color:#a6e22e>c</span>)

	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Signal</span>, <span style=color:#ae81ff>1</span>)
	<span style=color:#a6e22e>signal</span>.<span style=color:#a6e22e>Notify</span>(<span style=color:#a6e22e>ch</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Interrupt</span>)
	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>broadcast</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Cond</span>) {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>StoreInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>status</span>, <span style=color:#ae81ff>1</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Broadcast</span>()
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Unlock</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>listen</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Cond</span>) {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>status</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Wait</span>()
	}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;listen&#34;</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Unlock</span>()
}

<span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>run</span> <span style=color:#a6e22e>main</span>.<span style=color:#66d9ef>go</span>
<span style=color:#a6e22e>listen</span>
<span style=color:#f92672>...</span>
<span style=color:#a6e22e>listen</span>
</code></pre></div><p>上述代码同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情：</p>
<ul>
<li>10 个 Goroutine 通过 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58><code>sync.Cond.Wait</code></a> 等待特定条件的满足；</li>
<li>1 个 Goroutine 会调用 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76><code>sync.Cond.Broadcast</code></a> 方法通知所有陷入等待的 Goroutine；</li>
</ul>
<p>调用 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76><code>sync.Cond.Broadcast</code></a> 方法后，上述代码会打印出 10 次 “listen” 并结束调用。</p>
<p><img src=https://img.draveness.me/2020-01-23-15797104328042-golang-cond-broadcast.png alt=golang-cond-broadcast></p>
<p><strong>图 6-10 Cond 条件广播</strong></p>
<h3 id=结构体-1><a href=#结构体-1 class=h-anchor>#</a>结构体</h3>
<p><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29><code>sync.Cond</code></a> 的结构体中包含以下 4 个字段：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Cond</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>noCopy</span>  <span style=color:#a6e22e>noCopy</span>
	<span style=color:#a6e22e>L</span>       <span style=color:#a6e22e>Locker</span>
	<span style=color:#a6e22e>notify</span>  <span style=color:#a6e22e>notifyList</span>
	<span style=color:#a6e22e>checker</span> <span style=color:#a6e22e>copyChecker</span>
}
</code></pre></div><ul>
<li><code>noCopy</code> — 用于保证结构体不会在编译期间拷贝；</li>
<li><code>copyChecker</code> — 用于禁止运行期间发生的拷贝；</li>
<li><code>L</code> — 用于保护内部的 <code>notify</code> 字段，<code>Locker</code> 接口类型的变量；</li>
<li><code>notify</code> — 一个 Goroutine 的链表，它是实现同步机制的核心结构；</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>notifyList</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>wait</span> <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>notify</span> <span style=color:#66d9ef>uint32</span>

	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
	<span style=color:#a6e22e>head</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
	<span style=color:#a6e22e>tail</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
}
</code></pre></div><p>在 <a href=https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39><code>sync.notifyList</code></a> 结构体中，<code>head</code> 和 <code>tail</code> 分别指向的链表的头和尾，<code>wait</code> 和 <code>notify</code> 分别表示当前正在等待的和已经通知到的 Goroutine，我们通过这两个变量就能确认当前待通知和已通知的 Goroutine。</p>
<h3 id=接口-1><a href=#接口-1 class=h-anchor>#</a>接口</h3>
<p><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29><code>sync.Cond</code></a> 对外暴露的 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58><code>sync.Cond.Wait</code></a> 方法会将当前 Goroutine 陷入休眠状态，它的执行过程分成以下两个步骤：</p>
<ol>
<li>调用 <a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L479-L483><code>runtime.notifyListAdd</code></a> 将等待计数器加一并解锁；</li>
<li>调用 <a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518><code>runtime.notifyListWait</code></a> 等待其他 Goroutine 的唤醒并加锁：</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Wait</span>() {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>checker</span>.<span style=color:#a6e22e>check</span>()
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime_notifyListAdd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>notify</span>) <span style=color:#75715e>// runtime.notifyListAdd 的链接名
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#a6e22e>runtime_notifyListWait</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>notify</span>, <span style=color:#a6e22e>t</span>) <span style=color:#75715e>// runtime.notifyListWait 的链接名
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Lock</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>notifyListAdd</span>(<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>notifyList</span>) <span style=color:#66d9ef>uint32</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>wait</span>, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518><code>runtime.notifyListWait</code></a> 函数会获取当前 Goroutine 并将它追加到 Goroutine 通知链表的最末端：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>notifyListWait</span>(<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>notifyList</span>, <span style=color:#a6e22e>t</span> <span style=color:#66d9ef>uint32</span>) {
	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> = <span style=color:#a6e22e>t</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>tail</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>head</span> = <span style=color:#a6e22e>s</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>tail</span>.<span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>s</span>
	}
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>tail</span> = <span style=color:#a6e22e>s</span>
	<span style=color:#a6e22e>goparkunlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>waitReasonSyncCondWait</span>, <span style=color:#a6e22e>traceEvGoBlockCond</span>, <span style=color:#ae81ff>3</span>)
	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>s</span>)
}
</code></pre></div><p>除了将当前 Goroutine 追加到链表的末端之外，我们还会调用 <a href=https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309-L311><code>runtime.goparkunlock</code></a> 将当前 Goroutine 陷入休眠状态，该函数也是在 Go 语言切换 Goroutine 时经常会使用的方法，它会直接让出当前处理器的使用权并等待调度器的唤醒。</p>
<p><img src=https://img.draveness.me/2020-01-23-15797104328049-golang-cond-notifylist.png alt=golang-cond-notifylist></p>
<p><strong>图 6-11 Cond 条件通知列表</strong></p>
<p><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67><code>sync.Cond.Signal</code></a> 和 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76><code>sync.Cond.Broadcast</code></a> 方法就是用来唤醒调用 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58><code>sync.Cond.Wait</code></a> 陷入休眠的 Goroutine，它们两个的实现有一些细微差别：</p>
<ul>
<li><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67><code>sync.Cond.Signal</code></a> 方法会唤醒队列最前面的 Goroutine；</li>
<li><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76><code>sync.Cond.Broadcast</code></a> 方法会唤醒队列中全部的 Goroutine；</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Signal</span>() {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>checker</span>.<span style=color:#a6e22e>check</span>()
	<span style=color:#a6e22e>runtime_notifyListNotifyOne</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>notify</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Broadcast</span>() {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>checker</span>.<span style=color:#a6e22e>check</span>()
	<span style=color:#a6e22e>runtime_notifyListNotifyAll</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>notify</span>)
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L554-L604><code>runtime.notifyListNotifyOne</code></a> 函数只会从 <a href=https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39><code>sync.notifyList</code></a> 链表中找到满足 <code>sudog.ticket == l.notify</code> 条件的 Goroutine 并通过 <code>readyWithTime</code> 唤醒：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>notifyListNotifyOne</span>(<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>notifyList</span>) {
	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>notify</span>
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>notify</span>, <span style=color:#a6e22e>t</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>)(<span style=color:#66d9ef>nil</span>), <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>head</span>; <span style=color:#a6e22e>s</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>next</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>t</span> {
			<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>next</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>n</span>
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>head</span> = <span style=color:#a6e22e>n</span>
			}
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>tail</span> = <span style=color:#a6e22e>p</span>
			}
			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>next</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#a6e22e>readyWithTime</span>(<span style=color:#a6e22e>s</span>, <span style=color:#ae81ff>4</span>)
			<span style=color:#66d9ef>return</span>
		}
	}
}
</code></pre></div><p><a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L522-L550><code>runtime.notifyListNotifyAll</code></a> 会依次通过 <a href=https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L79-L84><code>runtime.readyWithTime</code></a> 函数唤醒链表中 Goroutine：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>notifyListNotifyAll</span>(<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>notifyList</span>) {
	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>head</span>
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>head</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>tail</span> = <span style=color:#66d9ef>nil</span>

	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>notify</span>, <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>wait</span>))

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>next</span>
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>next</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>readyWithTime</span>(<span style=color:#a6e22e>s</span>, <span style=color:#ae81ff>4</span>)
		<span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>next</span>
	}
}
</code></pre></div><p>Goroutine 的唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒，而后加入的 Goroutine 需要等待调度器的调度。</p>
<p>在一般情况下，我们都会先调用 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58><code>sync.Cond.Wait</code></a> 陷入休眠等待满足期望条件，当满足唤醒条件时，就可以选择使用 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67><code>sync.Cond.Signal</code></a> 或者 <a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76><code>sync.Cond.Broadcast</code></a> 唤醒一个或者全部的 Goroutine。</p>
<h3 id=小结-2><a href=#小结-2 class=h-anchor>#</a>小结</h3>
<p><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29><code>sync.Cond</code></a> 不是一个常用的同步机制，在遇到长时间条件无法满足时，与使用 <code>for {}</code> 进行忙碌等待相比，<a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29><code>sync.Cond</code></a> 能够让出处理器的使用权。在使用的过程中我们需要注意以下问题：</p>
<ul>
<li><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58><code>sync.Cond.Wait</code></a> 方法在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li>
<li><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67><code>sync.Cond.Signal</code></a> 方法唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li>
<li><a href=https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76><code>sync.Cond.Broadcast</code></a> 会按照一定顺序广播通知等待的全部 Goroutine；</li>
</ul>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=/posts/wechat/>
<span class=button__icon>←</span>
<span class=button__text>WeChat</span>
</a>
</span>
<span class="button next">
<a href=/posts/linux%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4/>
<span class=button__text>linux相关指令</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
<script>localStorage.getItem('theme')=='dark'&&document.documentElement.classList.add('dark-mode')</script>
<div id=light-mode>
<script src=https://utteranc.es/client.js repo=gongqij/blog_comment issue-term=title theme=github-light crossorigin=anonymous async></script>
</div>
<div id=dark-mode>
<script src=https://utteranc.es/client.js repo=gongqij/blog_comment issue-term=title theme=github-dark crossorigin=anonymous async></script>
</div>
<script>var root=document.getElementsByClassName("dark-mode");root.length>0?(document.getElementById("light-mode").style.display="none",document.getElementById("dark-mode").style.display="block"):(document.getElementById("light-mode").style.display="block",document.getElementById("dark-mode").style.display="none")</script>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__text>K:)eep</span>
</a>
<div class=copyright>
<span>© 2021 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
</div>
</div>
</footer>
<script src=/assets/main.js></script>
<script src=/assets/prism.js></script>
</div>
</body>
</html>